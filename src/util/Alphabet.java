package util;

import java.util.HashMap;
import java.util.Map;

public final class Alphabet { // запрещаем наследоваться что бы никто не создал новый объект
    private Alphabet(){} // запрещаем создавать новые объекты, никаких новых буковок
    public static final char[] ALPHABET = { 'а','б','в','г','д','е','ё','ж','з',
                                            'и','й','к','л','м','н','о','п','р',
                                            'с','т','у', 'ф','х','ц','ч','ш','щ',
                                            'ъ','ы','ь','э','ю','я','.', ',', '«',
                                            '»', '"', '\'', ':', '-', '!', '?', ' ',
                                            '0','1','2','3','4','5','6','7','8','9'};
    /*
    Используем HashMap, а не TreeMap потому что мы знаем что алфавит фиксированный массив, нам нужно находить индекс индекс символа
    а не сортировать как обычный алфавит, в нашем случае порядок роли не играет
    а ещё хэщмапа быстрее чем тримапа потому что она строит дерево
    массив долгий, каждый раз перебирает весь массив для поиска символа, в брут форсе будет критично при большом тексте
     */

    public static final Map<Character, Integer> INDEX; //Character - ключ(Символ алфавита), Integer - значение(индекс символа)//

    static { //Инициализируем таблицу 1 раз когда загружаем Alphabet в память
        Map<Character, Integer> map = new HashMap<>();
        for (int i = 0; i < ALPHABET.length; i++) { //Проходим по всей мапе
            map.put(ALPHABET[i], i); //На каждой итерации кладём пару значений, будет А->0,б->1,В->2
        }
        INDEX = Map.copyOf(map); // делает неизменяемую копию, которую можно только читать, пишем в INDEX короче
    }

    public static int indexOf(char ch) { //принимает символ ch
        return INDEX.getOrDefault(ch, -1); // смотрит есть ли символ в INDEX, если нет символ не входит в алфавит возвращает -1
                    //getOrDefault защищает от ошибки NullPointerException
    }

    public static int size() {
        return ALPHABET.length; //возвращает длину алфавита что бы знать диапазон сдвига для шифровки
    }
}




